{"version":3,"sources":["views/MoviesPageView.module.css","components/MoviePreview/MoviePreview.module.css","components/MoviesList/MoviesList.module.css","components/MoviePreview/MoviePreview.jsx","components/MoviesList/MoviesList.jsx","views/MoviesPageView.jsx"],"names":["module","exports","MoviePreview","poster_path","title","release_date","className","m","src","alt","slice","withRouter","movies","location","moviesList","map","id","item","to","pathname","state","from","MoviesPageView","formValue","status","handleChange","e","value","currentTarget","setState","toLowerCase","handleSubmit","preventDefault","handleClear","localStorage","removeItem","getItem","formValueFromStorage","parsedMovies","JSON","parse","parsedFormValue","this","a","props","API","mainUrl","length","Axios","get","searchQuery","data","results","setItem","stringify","container","headBlock","formBar","onSubmit","type","onClick","name","onChange","Component"],"mappings":"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","file":"static/js/movies-page-view.a94b3a73.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"MoviesPageView_container__11pun\",\"headBlock\":\"MoviesPageView_headBlock__1mWdC\",\"formBar\":\"MoviesPageView_formBar__19t6C\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"MoviePreview-thumb\":\"MoviePreview_MoviePreview-thumb__1K5ai\",\"MoviePreview-titleBlock\":\"MoviePreview_MoviePreview-titleBlock__JUGv0\",\"MoviePreview-title\":\"MoviePreview_MoviePreview-title__2o5eU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"moviesList\":\"MoviesList_moviesList__3rZPk\"};","import React from 'react';\nimport m from './MoviePreview.module.css';\n\nconst MoviePreview = ({ poster_path, title, release_date }) => {\n  return (\n    <div className={m[`MoviePreview-thumb`]}>\n      <img src={`https://image.tmdb.org/t/p/w500${poster_path}`} alt={title} />\n\n      <div className={m[`MoviePreview-titleBlock`]}>\n        <h5 className={m[`MoviePreview-title`]}>{`${title}`}</h5>\n\n        {release_date && (\n          <h5 className={m[`MoviePreview-title`]}>\n            {`(${release_date.slice(0, 4)})`}\n          </h5>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default MoviePreview;\n\n// 56. приняли пропсы и расписали как надо\n// --- добавили классы -> MovieDetailsPageView\n","import React from 'react';\nimport { Link, withRouter } from 'react-router-dom';\nimport MoviePreview from '../MoviePreview/MoviePreview';\nimport m from './MoviesList.module.css';\n\nconst MoviesList = ({ movies, location }) => {\n  return (\n    <ul className={m.moviesList}>\n      {movies.map(({ id, poster_path, title, release_date }) => (\n        <li key={id} className={m.item}>\n          <Link\n            to={{\n              pathname: `/movies/${id}`,\n              state: { from: location },\n            }}\n          >\n            <MoviePreview\n              poster_path={poster_path}\n              title={title}\n              release_date={release_date}\n            />\n          </Link>\n        </li>\n      ))}\n    </ul>\n  );\n};\n\nexport default withRouter(MoviesList);\n// Саша Репета для чего-то использовал User snippet reexport (посмотреть)\n\n// 52. переиспользуемый компонент MoviesList -> 45. MoviesPageView\n\n// 53. 3 пропа передаются только тому компоненту, который рендерится с помощью Route\n// --- в противном случае нужен {withRouter} (ф-ция или компонент высшего порядка? компонент-обёртка)\n// --- при экспорте вызывается как ф-ция с ссылкой на основную ф-цию withRouter(MoviesList)\n// --- сначала withRouter обворачивает нашу ф-цию, а потом под капотом в неё возвращает пропы, т.е. в HomePageView и MoviesPageView рендерится не MoviesList, а компонент зарендеренный withRouter с таким же именем MoviesList\n// 54. т.к. передаются разные url, нужно подготовить исходя из источника\n// --- вытягиваем его из match и вставляем динамически\n// --- или в нашем случае, т.к. постоянно переходим по одному адресу, жестко его прописать в Link to={/movies/}\n// --- withrouter в таком случае не нужен\n('---');\n// 55. делаем превьюшки фильмов -> MoviePreview\n// --- импортируем и рендерим в ссылку компонент превьюшки фильма\n// --- распыляем в него проп movie со всеми пропсами\n// --- но лучше кидать конкретные пропсы, а не все вподряд (так их видно конкретно и меньше)\n('---');\n// 58. в Link to= можно передать не только строку, но и объект настроек (props.location) {pathname: `/books/${id}`}\n// --- можно так же передавать state с информацией. этой информацией будет весь объект текущей локации location\n// --- state: {from: location} - проп, принятый {параметрах}, а чтоб он принялся нужен withRouter\n// --- теперь видим в location.state.from.pathname запись последнего url -> MovieDetailsPageView\n","import React, { Component } from 'react';\n// import { Route } from 'react-router-dom';\nimport Axios from 'axios';\nimport MoviesList from '../components/MoviesList';\n\nimport m from './MoviesPageView.module.css';\n\nclass MoviesPageView extends Component {\n  state = {\n    formValue: '',\n    movies: [],\n    status: 'idle',\n  };\n\n  componentDidMount() {\n    const moviesList = localStorage.getItem('movies');\n    const formValueFromStorage = localStorage.getItem('formValue');\n    const parsedMovies = JSON.parse(moviesList);\n    const parsedFormValue = JSON.parse(formValueFromStorage);\n\n    if (parsedMovies) {\n      this.setState({ movies: parsedMovies });\n      this.setState({ formValue: parsedFormValue });\n    }\n  }\n\n  async componentDidUpdate() {\n    const { API, mainUrl } = this.props;\n    const { formValue, status } = this.state;\n\n    if (status === 'pending' && formValue.length !== 0) {\n      const searchQuery = await Axios.get(\n        `${mainUrl}/search/movie?api_key=${API}&language=en-US&query=${formValue}&page=1&include_adult=false`,\n      );\n\n      this.setState({\n        movies: searchQuery.data.results,\n        status: 'resolved',\n        // formValue: '',\n      });\n\n      localStorage.setItem('movies', JSON.stringify(searchQuery.data.results));\n      localStorage.setItem('formValue', JSON.stringify(formValue));\n    }\n  }\n\n  handleChange = e => {\n    const { value } = e.currentTarget;\n\n    this.setState({ formValue: value.toLowerCase() });\n  };\n\n  handleSubmit = e => {\n    e.preventDefault();\n    // const { formValue } = this.state;\n\n    this.setState({\n      status: 'pending',\n    });\n  };\n\n  handleClear = () => {\n    this.setState({ formValue: '', movies: [], status: 'idle' });\n    localStorage.removeItem('movies');\n    localStorage.removeItem('formValue');\n  };\n\n  render() {\n    const { movies } = this.state;\n    // const { url, path } = this.props.match;\n    return (\n      <div className={m.container}>\n        <div className={m.headBlock}>\n          <form className={m.formBar} onSubmit={this.handleSubmit}>\n            <button type=\"button\" onClick={this.handleClear}>\n              Clear\n            </button>\n\n            <input\n              type=\"text\"\n              name=\"name\"\n              value={this.state.formValue}\n              onChange={this.handleChange}\n            />\n\n            <button type=\"submit\">Search</button>\n          </form>\n        </div>\n\n        <MoviesList movies={movies} />\n      </div>\n    );\n  }\n}\nexport default MoviesPageView;\n\n// status:\n// --- 'idle', - простаивание\n// --- 'pending', - ожидание\n// --- 'resolved', - разрешение\n// --- 'rejected' - отклонение\n('---');\n// 16. Для запроса нам нужен class и state для записи\n// 17. Для запросов импортируем Axios и делаем запрос, когда наш компонент маунтится (нажимаем на ссылку => меняется url в адресной строке => BrowserRouter реагирует и вызывает (маунтит) наш компонент MoviesPageView)\n// 18. В консоли видим результат запроса, записываем массив фильмов в state (каждый раз заново, не от предыдущего)\n// 19. Рендерим разметку для списка книг, достаём фильмы из стейта и мапим, вставляем id в <li> и рендерим title каждой книги\n('---');\n// 20. Теперь делаем встроенную навигацию - при нажарии на название (превью) фильма из общего списка, нас должно перекидывать на детальное описание фильма\n// 21. Нам нужно из названия сделать ссылку, но чтоб страница не перезагружалась - это { Link }, импортируем обворачиваем в него наши title\n// 22. В проп to=\"\" нужно вставить не статический, а динамический адрес, а чтоб у каждой книги был свой - определителем будет id\n('---');\n// 23. Использование во вложенной навигации постоянно в to= /movies - это антипаттерн магических строк, это плохо, потому что /movies уже используется под основную навигацию. Когда Route path=\"\" совпадает с текущим url (pathname)? то зарендеренный компонент (например наш MoviesPageView) получает от react-router три дополнительных пропса:\n// - history (объект для работы с историей)\n// - location (обьект, описывающий текущий путь в адресной строке, url)\n// --- hash: \"\" (описывает якорь)\n// --- key: \"234h4j\" (ID записи в истории)\n// --- pathname: \"/movies\" (тот, что мы пишем в рауте)\n// --- search: \"\" (query-стрим)\n// --- state: \"\"\n// - match (инфа от совпадении текущего маршрута с url)\n// --- isExact: true (если совпал)\n// --- params: {}\n// --- path: \"/movies\" (шаблон, на который зарендерился текущий раут, используем для создания вложенных маршрутов)\n// --- url: \"/movies\" (то, что записано в адресной строке, используем для создания вложенной навигации)\n\n// 24. консолим этот url (this.props.match.url) и смотрим, что он сходится с нашим to={/movies}  (или смотрим в React Tools - Components)\n// 25. поэтому мы можем вместо статической записи вставить наш динамический проп\n('---');\n// Теперь нам нужно сделать компонент, который будет рендериться на отдельный фильм - это отдельная страница MovieDetailsPageView\n('---');\n// 40. переносим весь код из MoviesPageView в HomePageView, т.к. это должна быть страница с формой поиска\n// 41. делаем форму для поиска фильмов по ключевому слову\n// --- форма с onSubmit и без label\n// --- input с type, name, value, onChange\n// ------ value должно отображать то, что записывается в state\n// ------ onChange должен вызывать метод handleChange, который\n// --- кнопка submit\n// 42. handleChange записывает в state значение {value} (с нижним регистром) в событии e.currentTarget\n// 43. handleSubmit должен иметь неперегружайку e.preventDefault();\n// --- переписывает статус на одидающий\n// 44. Т.к. у нас state перезаписывается каждый раз при изменениях в форме, то для запроса нужно использовать componentDidUpdate, потому что только в этом случае будет запрос последних изменений в форме\n// --- при componentDidUpdate нужно обязательно задать условие if () иначе цикличность\n// --- при смене статуса делаем запрос\n// --- меняем статус на подтверждённый\n// --- пишем ответ в state.movies\n// --- очищаем форму\n// -> App\n('---');\n// -> 52. MoviesList\n// 45. рендерим с пропами <MoviesList movies={this.state.movies} url={this.props.match.url} />\n// 46. переделываем на внутреннюю маршрутизацию Route\n// --- в path мы используем динамику, но не match.url, а match.path\n// 47. переиспользуем компонент MoviesList закидывая в него такие же пропсы как и в MoviesPageView, но с другим пропсом url={}\n// --- для законсоливания данных, можно использовать по данным в state или props метод .find()\n('КНОПКА НАЗАД');\n// 48. используем localStorage\n// --- условия те же, что и при запросе\n// --- при апдейте записываем в сторэдж this.state.movies и this.state.formValue\n// --- при маунте достаём из сторэджа и парсим\n// --- при условии наличия парса сетим по местам\n\n('КНОПКА CLEAR');\n// 50. удаляем данные в сторэдже и стейтим дэфолтные значения -> HomePageView\n"],"sourceRoot":""}