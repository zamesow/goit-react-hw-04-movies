{"version":3,"sources":["services/fetch-api.jsx","views/MovieDetailsPageView.module.css","views/MovieDetailsPageView.jsx"],"names":["IMG_URL","axios","defaults","baseURL","params","api_key","language","getCastAndReviews","movieId","a","url","append_to_response","data","alert","getSearchingMovies","formValue","query","results","getTrendingMovies","module","exports","Cast","lazy","Reviews","MovieDetailsPageView","state","title","genres","overview","release_date","vote_average","poster_path","cast","reviews","handleGoBack","history","props","lastPage","localStorage","getItem","parsedLastPage","JSON","parse","push","routes","movies","location","this","slug","match","then","castAndReviews","setState","credits","from","setItem","stringify","path","imgUrl","voteAverageInPercent","className","m","backBtn","type","onClick","MovieDetails","src","alt","description","slice","map","id","name","to","activeClassName","render","Component"],"mappings":"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","file":"static/js/movie-details-page-view.95f8a232.chunk.js","sourcesContent":["import axios from 'axios';\n\nconst BASE_URL = 'https://api.themoviedb.org/3/';\nconst API_KEY = '4f24a465004dec8d1f65f162bb769c3a';\nexport const IMG_URL = 'https://image.tmdb.org/t/p/w500/';\n\naxios.defaults.baseURL = BASE_URL;\naxios.defaults.params = {\n  api_key: API_KEY,\n  language: 'ru-RU',\n};\n\n// запрос на карточку фильма\nexport const getCastAndReviews = async movieId => {\n  try {\n    const url = {\n      url: `movie/${movieId}`,\n      params: {\n        append_to_response: 'credits,reviews',\n      },\n    };\n    const { data } = await axios(url, movieId);\n    return data;\n  } catch (error) {\n    alert(error);\n    return null;\n  }\n};\n\n// запрос на поиск фильмов\nexport const getSearchingMovies = async formValue => {\n  try {\n    const url = {\n      url: 'search/movie',\n      params: {\n        query: formValue,\n        // page: 1,\n        // include_adult: false,\n      },\n    };\n    const { data } = await axios(url);\n    // console.log(data.results);\n    return data.results;\n  } catch (error) {\n    alert(error);\n    return null;\n  }\n};\n\n// запрос на фильмы в тренде на главной странице\nexport const getTrendingMovies = async () => {\n  try {\n    const url = { url: 'trending/movie/week' };\n    const { data } = await axios(url);\n    // console.log(data.results);\n    return data.results;\n  } catch (error) {\n    alert(error);\n    return null;\n  }\n};\n\n('axios');\n// импорт axios\n// --- export на каждый элемент, который передаём\n// --- note // ! почему не default? - конспект\n\n// задаём КОНСТАНТЫ\n// --- рапределить по axios.defaults\n// --- они будут под капотом в каждом запросе\n// --- --- axios.defaults.baseURL = BASE_URL;\n// --- --- axios.defaults.params = { [ключ: значение] как в запросе параметры [ключ=значение] }\n\n// async перед ф-цией\n// - try { } catch (error) { alert(error); }\n// --- return и в try, и в catch\n// --- создаём объект настроек в try { }\n// --- const url = { url: 'trending/movie/week' } используется после [axios.defaults.baseURL]\n// --- --- const { data } = await axios(url);\n// --- если { url: `movie/${movieId}` } с интерполяцией, то параметр ф-ции кидаем в axios дальше\n// --- --- const { data } = await axios(url, movieId); [сразу с деструктуризацией ответа]\n// --- если в адресе запроса есть ещё параметры, прописываем их тоже в url = {}:\n// --- --- url = { url: 'trending/movie/week', params: { append_to_response: 'credits,reviews' } };\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"MovieDetails\":\"MovieDetailsPageView_MovieDetails__w972_\",\"description\":\"MovieDetailsPageView_description__cGngn\",\"genres\":\"MovieDetailsPageView_genres__2ywdv\",\"backBtn\":\"MovieDetailsPageView_backBtn__2WDeE\"};","import React, { Component, Suspense, lazy } from 'react';\nimport { NavLink, Route } from 'react-router-dom';\n// import Axios from 'axios';\nimport { getCastAndReviews, IMG_URL } from '../services/fetch-api';\nimport routes from '../routes';\n\nimport m from './MovieDetailsPageView.module.css';\n\nconst Cast = lazy(() =>\n  import('../components/Cast' /* webpackChunkName: \"cast\" */),\n);\n\nconst Reviews = lazy(() =>\n  import('../components/Reviews' /* webpackChunkName: \"reviews\" */),\n);\n\nclass MovieDetailsPageView extends Component {\n  state = {\n    title: '',\n    genres: [],\n    overview: '',\n    release_date: '',\n    vote_average: '',\n    poster_path: '',\n    cast: [],\n    reviews: [],\n  };\n\n  async componentDidMount() {\n    const { location } = this.props;\n    const { slug } = this.props.match.params;\n\n    const movieId = slug.match(/[a-z0-9]+$/)[0];\n\n    getCastAndReviews(movieId).then(castAndReviews =>\n      this.setState({\n        ...castAndReviews,\n        poster_path: IMG_URL + castAndReviews.poster_path,\n        cast: castAndReviews.credits.cast,\n        reviews: castAndReviews.reviews.results,\n      }),\n    );\n\n    // пишем в локалсторэдж, потому что при Cast или Reviews меняется url и возвращает не туда\n    if (location.state && location.state.from) {\n      localStorage.setItem('lastPage', JSON.stringify(location.state.from));\n      // console.log(location.state.from);\n    }\n  }\n\n  handleGoBack = () => {\n    const { history } = this.props;\n\n    // if (location.state && location.state.from) {\n    //   return history.push(location.state.from);\n    // }\n\n    // берём из локалсторэдж, потому что при Cast или Reviews меняется url и возвращает не туда\n    const lastPage = localStorage.getItem('lastPage');\n    const parsedLastPage = JSON.parse(lastPage);\n\n    if (parsedLastPage) {\n      // console.log(parsedLastPage);\n      return history.push(parsedLastPage || routes.movies);\n    }\n\n    // history.push(location?.state?.from || routes.movies);\n  };\n\n  render() {\n    const {\n      title,\n      release_date,\n      genres,\n      poster_path,\n      overview,\n      vote_average,\n      cast,\n      reviews,\n    } = this.state;\n    const { movies } = this.props;\n    const { url, path } = this.props.match;\n    const imgUrl = poster_path;\n    const voteAverageInPercent = vote_average * 10 + '%';\n    // console.log(release_date.slice(0, 4));\n    // console.log(`send:`, cast);\n    // console.log(this.props.location.state.from);\n    return (\n      <>\n        {/* <Link to={location?.state?.from ?? routes.movies}>\n          {location?.state?.from ?? 'Назад'}\n        </Link> */}\n\n        <button\n          className={m.backBtn}\n          type=\"button\"\n          onClick={this.handleGoBack}\n          movies={movies}\n        >\n          Назад\n        </button>\n\n        {title && (\n          <div>\n            <div className={m.MovieDetails}>\n              <img src={`${imgUrl}`} alt={`poster ${title}`} />\n              <div className={m.description}>\n                <h1>{`${title} (${\n                  release_date ? release_date.slice(0, 4) : 'Coming soon'\n                })`}</h1>\n                {vote_average ? (\n                  <p>{`User score: ${voteAverageInPercent}`}</p>\n                ) : (\n                  ''\n                )}\n\n                {overview && <h3>Overview</h3>}\n                <p>{overview}</p>\n\n                <h4>Genres</h4>\n                <ul className={m.genres}>\n                  {genres.map(({ id, name }) => (\n                    <li key={id}>{name}</li>\n                  ))}\n                </ul>\n              </div>\n            </div>\n            <hr />\n\n            <p>Addidition information</p>\n\n            <ul>\n              <li>\n                <NavLink\n                  to={`${url}/cast`}\n                  className=\"NavLink\"\n                  activeClassName=\"NavLink--active\"\n                >\n                  Cast\n                </NavLink>\n              </li>\n\n              <li>\n                <NavLink\n                  to={`${url}/reviews`}\n                  className=\"NavLink\"\n                  activeClassName=\"NavLink--active\"\n                >\n                  Reviews\n                </NavLink>\n              </li>\n            </ul>\n\n            <hr />\n\n            <Suspense>\n              <Route\n                path={`${path}/cast`}\n                render={props => {\n                  return <Cast {...props} cast={cast} />;\n                }}\n              />\n              <Route\n                path={`${path}/reviews`}\n                render={props => {\n                  return <Reviews {...props} reviews={reviews} />;\n                }}\n              />\n            </Suspense>\n          </div>\n        )}\n      </>\n    );\n  }\n}\n\nexport default MovieDetailsPageView;\n\n// 26. создаём class. Рендерить этот компонент мы хотим после (вместо) списка всех видео, после добавлению к адресу id выбранного фильма, например /books/:bookId - это просто строка, сама по себе ничего не означающая, \":\" значит динамический параметр, означает, что реагировать на всё, что будет после /books/. Эту строку адреса мы так же можем записать в раут App...\n\n// 28. переходим на нашей страничке в Movies и смотрим в тулзы, видим, что зарендерен MoviesPageView, смотрим в его проп match и видим, что isExact: true, а path и url совпадают, но это не значит, что они одинаковые...\n// переходим на страницу одного фильма, смотрим туда же на пропы и видим, что isExact: true, а path и url разные.\n// смотрим на проп params и видим, что у него идёт определение {path: url}, это как раз потому что в нашем рауте в path стоит динамический параметр \":\", означающий, что запись после него movieId - это лишь переменная.\n// 29. поэтому, чтобы при переходе на страницу одной книги нам сразу писался идентификатор фильма, мы може писать в заглавии {this.props.match.params.movieId}\n// доступ к идентификатору нужен не для названия, а для нового запроса к фильму по id? потому что на эту страницу мы можем перейти не только из /movies, но и набрав вручную, а если до этого небыло запроса на все книги, то и из state в /movies нечего брать\n// --- при маунте можем консолить пропсы для наглядности\n// 30. делаем запрос при маунте, где параметром книги делаем наш проп с id. Поэтому тут class.\n// 31. приходит объект со свойством data и у того объект свойств. Все свойства нам не нужны, поэтому мы можем выбрать необходимые, записать их в стейт и распылить нужный ответ в стейт.\n// 32. Рендерим разметку:\n// --- деструктуризируем стейт, вытягиваем свойства\n// --- деструктуризируем значение {movieId} из пропса this.props.match.params\n// ---находим в доках правильный запрос для картинок и присваеваем его переменной imageUrl\n// --- прописываем разметку для названия, года, рейтинга, описания, постера и жанров\n('---');\n// теперь делаем вложенный маршрут - это когда на той же странице не переходя на другую у нас открывается что-то, в данном случае - это информации о актёрском составе и обзоры. Раут - это просто компонент, мы можем его вставлять в рендере другого компонента. Так как у нас только кусочек страницы, то мы можем делать не view, а просто компонент\n// 33. импортируем NavLink, обворачиваем в него Cast и Review и прописываем to=\"/movies/:movieId/cast\" и \".../review\". В to= первую часть url нужно тоже писать динамикой, как мы это делали в MoviesPageView to={`${this.props.match.url}/cast`}\n// 34. для добавлеия вложенного свойства Cast в запросе нужно добавить не _embed=credits (_expand=credits), а дополнительный параметр, указаный в доках на сайте &append_to_response=credits после. Смотрим в тулзах на компонент MovieDetailsPageView, на его state.\n// 35. нам нужно передать из MovieDetailsPageView в Cast id фильма, сделать это можно через СПЕЦИАЛЬНЫЙ проп render={props => <Cast {...props} /> }. Передавать нужно ф-цию, в которую будут приходить пропы раутера (history, location, match), они передаются автоматически, если мы передаём через component={}, а через рендер нужно вручную, на выходе наш тег с компонентом и в него распыляем эти пропсы и наш список Cast из стейта.\n// 36. повторяем с Review и переходим к этим компонентам\n('Кнопка НАЗАД');\n// 57. добавляем кнопку\n// --- смотрим на props.history.push и .replace - нам нужно записать новую запись, взятую из истории\n// --- пример с onClick={() => this.props.history.push('/')}\n// --- надо рауту MovieDetailsPageView сказать с какого url мы пришли? -> MoviesList\n// 59. проверяем с какого url приходим console.log(this.props.location.state.from);\n// --- прописываем в onClick={() => this.props.history.push(this.props.location.state.from)}\n// --- dsyjcbv это в отдельный метод handleGoBack\n// 60. что делать, если пользователь зашел по конечному адресу с пустой страницы?\n// --- в таком случае будет location.state: undefined\n// --- в handleGoBack пушим при выполнении условия проверки на if(location.state && location.state.from)\n// --- если условие не выполняется, то перекидываем на страницу запроса (через готовый импортированный раут)\n// --- так же есть современный метод проверки вложенных свойств с помощью оператора \"?.\", но в результируещем бандле код будет больше, поэтому пока новые технологии не вошли в обиход, лучше писать по олдскульному\n// так же можно использовать не метод handleGoBack и кнопку, а ссылку <Link to={location?.state?.from ?? routes.movies}>{location?.state?.from ?? 'Назад'}</Link>\n\n// из-за изменений в url при раутах Cast или Review и при нажатии на кнопку НАЗАД нас выкидывает не на страницу назад, а всегда на routes.movies, поэтому используем запись в локалсторэдж\n// -> App\n\n('Suspense, lazy - 01:13:00');\n// 63. import {Suspense, lazy}\n// --- удаляем статические импорты и добавляем lazy()\n// --- обворачивать в <Suspense> можно рауты или конкретно добавляемые компоненты\n\n('Slug');\n// меняем проп movieId на { slug } = this.props.match.params;\n// меняем в запросе movieId на slug\n\n// 74. нам нужно вытащить id с этого слага\n// --- мы не може заранее знать сколько будет символов после /movies/\n// --- нужно написать регулярное выражение\n// --- переходим в regex101.com\n// --- вписываем наш url в test string\n// --- в regular expression вписываем условие выражения [a-z0-9]+$ (группа из букв и цифр на которую заканчивается строка)\n// --- можем прверить console.log(slug.match(/[a-z0-9]+$/));\n// --- .match() возвращает первое совпадение по заданому паттерну (регулярному выражению)\n// --- из-за того, что нам приходит массив данных, нам нужен элемент под индексом [0]\n// 75. вписываем наше выражение в переменную const movieId = slug.match(/[a-z0-9]+$/)[0];\n// --- меняем далее slug сново на movieId\n// --- лучше делать отдельную ф-цию типа slagGet\n\n// note // ! проверить routes.cast и routes.review\n"],"sourceRoot":""}